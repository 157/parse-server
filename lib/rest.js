"use strict";

// This file contains helpers for running operations in REST format.
// The goal is that handlers that explicitly handle an express route
// should just be shallow wrappers around things in this file, but
// these functions should not explicitly depend on the request
// object.
// This means that one of these handlers can support multiple
// routes. That's useful for the routes that do really similar
// things.
var Parse = require('parse/node').Parse;

var RestQuery = require('./RestQuery');

var RestWrite = require('./RestWrite');

var triggers = require('./triggers');

function checkTriggers(className, config, types) {
  return types.some(triggerType => {
    return triggers.getTrigger(className, triggers.Types[triggerType], config.applicationId);
  });
}

function checkLiveQuery(className, config) {
  return config.liveQueryController && config.liveQueryController.hasLiveQuery(className);
} // Returns a promise for an object with optional keys 'results' and 'count'.


function find(config, auth, className, restWhere, restOptions, clientSDK, context) {
  enforceRoleSecurity('find', className, auth);
  return triggers.maybeRunQueryTrigger(triggers.Types.beforeFind, className, restWhere, restOptions, config, auth, context).then(result => {
    restWhere = result.restWhere || restWhere;
    restOptions = result.restOptions || restOptions;
    const query = new RestQuery(config, auth, className, restWhere, restOptions, clientSDK);
    return query.execute();
  });
} // get is just like find but only queries an objectId.


const get = (config, auth, className, objectId, restOptions, clientSDK, context) => {
  var restWhere = {
    objectId
  };
  enforceRoleSecurity('get', className, auth);
  return triggers.maybeRunQueryTrigger(triggers.Types.beforeFind, className, restWhere, restOptions, config, auth, context, true).then(result => {
    restWhere = result.restWhere || restWhere;
    restOptions = result.restOptions || restOptions;
    const query = new RestQuery(config, auth, className, restWhere, restOptions, clientSDK);
    return query.execute();
  });
}; // Returns a promise that doesn't resolve to any useful value.


function del(config, auth, className, objectId, context) {
  if (typeof objectId !== 'string') {
    throw new Parse.Error(Parse.Error.INVALID_JSON, 'bad objectId');
  }

  if (className === '_User' && auth.isUnauthenticated()) {
    throw new Parse.Error(Parse.Error.SESSION_MISSING, 'Insufficient auth to delete user');
  }

  enforceRoleSecurity('delete', className, auth);
  let inflatedObject;
  let schemaController;
  return Promise.resolve().then(() => {
    const hasTriggers = checkTriggers(className, config, ['beforeDelete', 'afterDelete']);
    const hasLiveQuery = checkLiveQuery(className, config);

    if (hasTriggers || hasLiveQuery || className == '_Session') {
      return new RestQuery(config, auth, className, {
        objectId
      }).execute({
        op: 'delete'
      }).then(response => {
        if (response && response.results && response.results.length) {
          const firstResult = response.results[0];
          firstResult.className = className;

          if (className === '_Session' && !auth.isMaster) {
            if (!auth.user || firstResult.user.objectId !== auth.user.id) {
              throw new Parse.Error(Parse.Error.INVALID_SESSION_TOKEN, 'Invalid session token');
            }
          }

          var cacheAdapter = config.cacheController;
          cacheAdapter.user.del(firstResult.sessionToken);
          inflatedObject = Parse.Object.fromJSON(firstResult);
          return triggers.maybeRunTrigger(triggers.Types.beforeDelete, auth, inflatedObject, null, config, context);
        }

        throw new Parse.Error(Parse.Error.OBJECT_NOT_FOUND, 'Object not found for delete.');
      });
    }

    return Promise.resolve({});
  }).then(() => {
    if (!auth.isMaster) {
      return auth.getUserRoles();
    } else {
      return;
    }
  }).then(() => config.database.loadSchema()).then(s => {
    schemaController = s;
    const options = {};

    if (!auth.isMaster) {
      options.acl = ['*'];

      if (auth.user) {
        options.acl.push(auth.user.id);
        options.acl = options.acl.concat(auth.userRoles);
      }
    }

    return config.database.destroy(className, {
      objectId: objectId
    }, options, schemaController);
  }).then(() => {
    // Notify LiveQuery server if possible
    const perms = schemaController.getClassLevelPermissions(className);
    config.liveQueryController.onAfterDelete(className, inflatedObject, null, perms);
    return triggers.maybeRunTrigger(triggers.Types.afterDelete, auth, inflatedObject, null, config, context);
  }).catch(error => {
    handleSessionMissingError(error, className, auth);
  });
} // Returns a promise for a {response, status, location} object.


function create(config, auth, className, restObject, clientSDK, context) {
  enforceRoleSecurity('create', className, auth);
  var write = new RestWrite(config, auth, className, null, restObject, null, clientSDK, context);
  return write.execute();
} // Returns a promise that contains the fields of the update that the
// REST API is supposed to return.
// Usually, this is just updatedAt.


function update(config, auth, className, restWhere, restObject, clientSDK, context) {
  enforceRoleSecurity('update', className, auth);
  return Promise.resolve().then(() => {
    const hasTriggers = checkTriggers(className, config, ['beforeSave', 'afterSave']);
    const hasLiveQuery = checkLiveQuery(className, config);

    if (hasTriggers || hasLiveQuery) {
      // Do not use find, as it runs the before finds
      return new RestQuery(config, auth, className, restWhere, undefined, undefined, false).execute({
        op: 'update'
      });
    }

    return Promise.resolve({});
  }).then(({
    results
  }) => {
    var originalRestObject;

    if (results && results.length) {
      originalRestObject = results[0];
    }

    return new RestWrite(config, auth, className, restWhere, restObject, originalRestObject, clientSDK, context, 'update').execute();
  }).catch(error => {
    handleSessionMissingError(error, className, auth);
  });
}

function handleSessionMissingError(error, className, auth) {
  // If we're trying to update a user without / with bad session token
  if (className === '_User' && error.code === Parse.Error.OBJECT_NOT_FOUND && !auth.isMaster) {
    throw new Parse.Error(Parse.Error.SESSION_MISSING, 'Insufficient auth.');
  }

  throw error;
}

const classesWithMasterOnlyAccess = ['_JobStatus', '_PushStatus', '_Hooks', '_GlobalConfig', '_JobSchedule', '_Idempotency']; // Disallowing access to the _Role collection except by master key

function enforceRoleSecurity(method, className, auth) {
  if (className === '_Installation' && !auth.isMaster) {
    if (method === 'delete' || method === 'find') {
      const error = `Clients aren't allowed to perform the ${method} operation on the installation collection.`;
      throw new Parse.Error(Parse.Error.OPERATION_FORBIDDEN, error);
    }
  } //all volatileClasses are masterKey only


  if (classesWithMasterOnlyAccess.indexOf(className) >= 0 && !auth.isMaster) {
    const error = `Clients aren't allowed to perform the ${method} operation on the ${className} collection.`;
    throw new Parse.Error(Parse.Error.OPERATION_FORBIDDEN, error);
  } // readOnly masterKey is not allowed


  if (auth.isReadOnly && (method === 'delete' || method === 'create' || method === 'update')) {
    const error = `read-only masterKey isn't allowed to perform the ${method} operation.`;
    throw new Parse.Error(Parse.Error.OPERATION_FORBIDDEN, error);
  }
}

module.exports = {
  create,
  del,
  find,
  get,
  update
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9yZXN0LmpzIl0sIm5hbWVzIjpbIlBhcnNlIiwicmVxdWlyZSIsIlJlc3RRdWVyeSIsIlJlc3RXcml0ZSIsInRyaWdnZXJzIiwiY2hlY2tUcmlnZ2VycyIsImNsYXNzTmFtZSIsImNvbmZpZyIsInR5cGVzIiwic29tZSIsInRyaWdnZXJUeXBlIiwiZ2V0VHJpZ2dlciIsIlR5cGVzIiwiYXBwbGljYXRpb25JZCIsImNoZWNrTGl2ZVF1ZXJ5IiwibGl2ZVF1ZXJ5Q29udHJvbGxlciIsImhhc0xpdmVRdWVyeSIsImZpbmQiLCJhdXRoIiwicmVzdFdoZXJlIiwicmVzdE9wdGlvbnMiLCJjbGllbnRTREsiLCJjb250ZXh0IiwiZW5mb3JjZVJvbGVTZWN1cml0eSIsIm1heWJlUnVuUXVlcnlUcmlnZ2VyIiwiYmVmb3JlRmluZCIsInRoZW4iLCJyZXN1bHQiLCJxdWVyeSIsImV4ZWN1dGUiLCJnZXQiLCJvYmplY3RJZCIsImRlbCIsIkVycm9yIiwiSU5WQUxJRF9KU09OIiwiaXNVbmF1dGhlbnRpY2F0ZWQiLCJTRVNTSU9OX01JU1NJTkciLCJpbmZsYXRlZE9iamVjdCIsInNjaGVtYUNvbnRyb2xsZXIiLCJQcm9taXNlIiwicmVzb2x2ZSIsImhhc1RyaWdnZXJzIiwib3AiLCJyZXNwb25zZSIsInJlc3VsdHMiLCJsZW5ndGgiLCJmaXJzdFJlc3VsdCIsImlzTWFzdGVyIiwidXNlciIsImlkIiwiSU5WQUxJRF9TRVNTSU9OX1RPS0VOIiwiY2FjaGVBZGFwdGVyIiwiY2FjaGVDb250cm9sbGVyIiwic2Vzc2lvblRva2VuIiwiT2JqZWN0IiwiZnJvbUpTT04iLCJtYXliZVJ1blRyaWdnZXIiLCJiZWZvcmVEZWxldGUiLCJPQkpFQ1RfTk9UX0ZPVU5EIiwiZ2V0VXNlclJvbGVzIiwiZGF0YWJhc2UiLCJsb2FkU2NoZW1hIiwicyIsIm9wdGlvbnMiLCJhY2wiLCJwdXNoIiwiY29uY2F0IiwidXNlclJvbGVzIiwiZGVzdHJveSIsInBlcm1zIiwiZ2V0Q2xhc3NMZXZlbFBlcm1pc3Npb25zIiwib25BZnRlckRlbGV0ZSIsImFmdGVyRGVsZXRlIiwiY2F0Y2giLCJlcnJvciIsImhhbmRsZVNlc3Npb25NaXNzaW5nRXJyb3IiLCJjcmVhdGUiLCJyZXN0T2JqZWN0Iiwid3JpdGUiLCJ1cGRhdGUiLCJ1bmRlZmluZWQiLCJvcmlnaW5hbFJlc3RPYmplY3QiLCJjb2RlIiwiY2xhc3Nlc1dpdGhNYXN0ZXJPbmx5QWNjZXNzIiwibWV0aG9kIiwiT1BFUkFUSU9OX0ZPUkJJRERFTiIsImluZGV4T2YiLCJpc1JlYWRPbmx5IiwibW9kdWxlIiwiZXhwb3J0cyJdLCJtYXBwaW5ncyI6Ijs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUEsSUFBSUEsS0FBSyxHQUFHQyxPQUFPLENBQUMsWUFBRCxDQUFQLENBQXNCRCxLQUFsQzs7QUFFQSxJQUFJRSxTQUFTLEdBQUdELE9BQU8sQ0FBQyxhQUFELENBQXZCOztBQUNBLElBQUlFLFNBQVMsR0FBR0YsT0FBTyxDQUFDLGFBQUQsQ0FBdkI7O0FBQ0EsSUFBSUcsUUFBUSxHQUFHSCxPQUFPLENBQUMsWUFBRCxDQUF0Qjs7QUFFQSxTQUFTSSxhQUFULENBQXVCQyxTQUF2QixFQUFrQ0MsTUFBbEMsRUFBMENDLEtBQTFDLEVBQWlEO0FBQy9DLFNBQU9BLEtBQUssQ0FBQ0MsSUFBTixDQUFXQyxXQUFXLElBQUk7QUFDL0IsV0FBT04sUUFBUSxDQUFDTyxVQUFULENBQ0xMLFNBREssRUFFTEYsUUFBUSxDQUFDUSxLQUFULENBQWVGLFdBQWYsQ0FGSyxFQUdMSCxNQUFNLENBQUNNLGFBSEYsQ0FBUDtBQUtELEdBTk0sQ0FBUDtBQU9EOztBQUVELFNBQVNDLGNBQVQsQ0FBd0JSLFNBQXhCLEVBQW1DQyxNQUFuQyxFQUEyQztBQUN6QyxTQUNFQSxNQUFNLENBQUNRLG1CQUFQLElBQ0FSLE1BQU0sQ0FBQ1EsbUJBQVAsQ0FBMkJDLFlBQTNCLENBQXdDVixTQUF4QyxDQUZGO0FBSUQsQyxDQUVEOzs7QUFDQSxTQUFT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Q0FBQ2lDLEtBQVYsQ0FBZ0JqQyxLQUFLLENBQUNpQyxLQUFOLENBQVlvRCxtQkFBNUIsRUFBaURYLEtBQWpELENBQU47QUFDRDtBQUNGLEdBTm1ELENBUXBEOzs7QUFDQSxNQUFJUywyQkFBMkIsQ0FBQ0csT0FBNUIsQ0FBb0NoRixTQUFwQyxLQUFrRCxDQUFsRCxJQUF1RCxDQUFDWSxJQUFJLENBQUM2QixRQUFqRSxFQUEyRTtBQUN6RSxVQUFNMkIsS0FBSyxHQUFJLHlDQUF3Q1UsTUFBTyxxQkFBb0I5RSxTQUFVLGNBQTVGO0FBQ0EsVUFBTSxJQUFJTixLQUFLLENBQUNpQyxLQUFWLENBQWdCakMsS0FBSyxDQUFDaUMsS0FBTixDQUFZb0QsbUJBQTVCLEVBQWlEWCxLQUFqRCxDQUFOO0FBQ0QsR0FabUQsQ0FjcEQ7OztBQUNBLE1BQ0V4RCxJQUFJLENBQUNxRSxVQUFMLEtBQ0NILE1BQU0sS0FBSyxRQUFYLElBQXVCQSxNQUFNLEtBQUssUUFBbEMsSUFBOENBLE1BQU0sS0FBSyxRQUQxRCxDQURGLEVBR0U7QUFDQSxVQUFNVixLQUFLLEdBQUksb0RBQW1EVSxNQUFPLGFBQXpFO0FBQ0EsVUFBTSxJQUFJcEYsS0FBSyxDQUFDaUMsS0FBVixDQUFnQmpDLEtBQUssQ0FBQ2lDLEtBQU4sQ0FBWW9ELG1CQUE1QixFQUFpRFgsS0FBakQsQ0FBTjtBQUNEO0FBQ0Y7O0FBRURjLE1BQU0sQ0FBQ0MsT0FBUCxHQUFpQjtBQUNmYixFQUFBQSxNQURlO0FBRWY1QyxFQUFBQSxHQUZlO0FBR2ZmLEVBQUFBLElBSGU7QUFJZmEsRUFBQUEsR0FKZTtBQUtmaUQsRUFBQUE7QUFMZSxDQUFqQiIsInNvdXJjZXNDb250ZW50IjpbIi8vIFRoaXMgZmlsZSBjb250YWlucyBoZWxwZXJzIGZvciBydW5uaW5nIG9wZXJhdGlvbnMgaW4gUkVTVCBmb3JtYXQuXG4vLyBUaGUgZ29hbCBpcyB0aGF0IGhhbmRsZXJzIHRoYXQgZXhwbGljaXRseSBoYW5kbGUgYW4gZXhwcmVzcyByb3V0ZVxuLy8gc2hvdWxkIGp1c3QgYmUgc2hhbGxvdyB3cmFwcGVycyBhcm91bmQgdGhpbmdzIGluIHRoaXMgZmlsZSwgYnV0XG4vLyB0aGVzZSBmdW5jdGlvbnMgc2hvdWxkIG5vdCBleHBsaWNpdGx5IGRlcGVuZCBvbiB0aGUgcmVxdWVzdFxuLy8gb2JqZWN0LlxuLy8gVGhpcyBtZWFucyB0aGF0IG9uZSBvZiB0aGVzZSBoYW5kbGVycyBjYW4gc3VwcG9ydCBtdWx0aXBsZVxuLy8gcm91dGVzLiBUaGF0J3MgdXNlZnVsIGZvciB0aGUgcm91dGVzIHRoYXQgZG8gcmVhbGx5IHNpbWlsYXJcbi8vIHRoaW5ncy5cblxudmFyIFBhcnNlID0gcmVxdWlyZSgncGFyc2Uvbm9kZScpLlBhcnNlO1xuXG52YXIgUmVzdFF1ZXJ5ID0gcmVxdWlyZSgnLi9SZXN0UXVlcnknKTtcbnZhciBSZXN0V3JpdGUgPSByZXF1aXJlKCcuL1Jlc3RXcml0ZScpO1xudmFyIHRyaWdnZXJzID0gcmVxdWlyZSgnLi90cmlnZ2VycycpO1xuXG5mdW5jdGlvbiBjaGVja1RyaWdnZXJzKGNsYXNzTmFtZSwgY29uZmlnLCB0eXBlcykge1xuICByZXR1cm4gdHlwZXMuc29tZSh0cmlnZ2VyVHlwZSA9PiB7XG4gICAgcmV0dXJuIHRyaWdnZXJzLmdldFRyaWdnZXIoXG4gICAgICBjbGFzc05hbWUsXG4gICAgICB0cmlnZ2Vycy5UeXBlc1t0cmlnZ2VyVHlwZV0sXG4gICAgICBjb25maWcuYXBwbGljYXRpb25JZFxuICAgICk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBjaGVja0xpdmVRdWVyeShjbGFzc05hbWUsIGNvbmZpZykge1xuICByZXR1cm4gKFxuICAgIGNvbmZpZy5saXZlUXVlcnlDb250cm9sbGVyICYmXG4gICAgY29uZmlnLmxpdmVRdWVyeUNvbnRyb2xsZXIuaGFzTGl2ZVF1ZXJ5KGNsYXNzTmFtZSlcbiAgKTtcbn1cblxuLy8gUmV0dXJucyBhIHByb21pc2UgZm9yIGFuIG9iamVjdCB3aXRoIG9wdGlvbmFsIGtleXMgJ3Jlc3VsdHMnIGFuZCAnY291bnQnLlxuZnVuY3Rpb24gZmluZChcbiAgY29uZmlnLFxuICBhdXRoLFxuICBjbGFzc05hbWUsXG4gIHJlc3RXaGVyZSxcbiAgcmVzdE9wdGlvbnMsXG4gIGNsaWVudFNESyxcbiAgY29udGV4dFxuKSB7XG4gIGVuZm9yY2VSb2xlU2VjdXJpdHkoJ2ZpbmQnLCBjbGFzc05hbWUsIGF1dGgpO1xuICByZXR1cm4gdHJpZ2dlcnNcbiAgICAubWF5YmVSdW5RdWVyeVRyaWdnZXIoXG4gICAgICB0cmlnZ2Vycy5UeXBlcy5iZWZvcmVGaW5kLFxuICAgICAgY2xhc3NOYW1lLFxuICAgICAgcmVzdFdoZXJlLFxuICAgICAgcmVzdE9wdGlvbnMsXG4gICAgICBjb25maWcsXG4gICAgICBhdXRoLFxuICAgICAgY29udGV4dFxuICAgIClcbiAgICAudGhlbihyZXN1bHQgPT4ge1xuICAgICAgcmVzdFdoZXJlID0gcmVzdWx0LnJlc3RXaGVyZSB8fCByZXN0V2hlcmU7XG4gICAgICByZXN0T3B0aW9ucyA9IHJlc3VsdC5yZXN0T3B0aW9ucyB8fCByZXN0T3B0aW9ucztcbiAgICAgIGNvbnN0IHF1ZXJ5ID0gbmV3IFJlc3RRdWVyeShcbiAgICAgICAgY29uZmlnLFxuICAgICAgICBhdXRoLFxuICAgICAgICBjbGFzc05hbWUsXG4gICAgICAgIHJlc3RXaGVyZSxcbiAgICAgICAgcmVzdE9wdGlvbnMsXG4gICAgICAgIGNsaWVudFNES1xuICAgICAgKTtcbiAgICAgIHJldHVybiBxdWVyeS5leGVjdXRlKCk7XG4gICAgfSk7XG59XG5cbi8vIGdldCBpcyBqdXN0IGxpa2UgZmluZCBidXQgb25seSBxdWVyaWVzIGFuIG9iamVjdElkLlxuY29uc3QgZ2V0ID0gKFxuICBjb25maWcsXG4gIGF1dGgsXG4gIGNsYXNzTmFtZSxcbiAgb2JqZWN0SWQsXG4gIHJlc3RPcHRpb25zLFxuICBjbGllbnRTREssXG4gIGNvbnRleHRcbikgPT4ge1xuICB2YXIgcmVzdFdoZXJlID0geyBvYmplY3RJZCB9O1xuICBlbmZvcmNlUm9sZVNlY3VyaXR5KCdnZXQnLCBjbGFzc05hbWUsIGF1dGgpO1xuICByZXR1cm4gdHJpZ2dlcnNcbiAgICAubWF5YmVSdW5RdWVyeVRyaWdnZXIoXG4gICAgICB0cmlnZ2Vycy5UeXBlcy5iZWZvcmVGaW5kLFxuICAgICAgY2xhc3NOYW1lLFxuICAgICAgcmVzdFdoZXJlLFxuICAgICAgcmVzdE9wdGlvbnMsXG4gICAgICBjb25maWcsXG4gICAgICBhdXRoLFxuICAgICAgY29udGV4dCxcbiAgICAgIHRydWVcbiAgICApXG4gICAgLnRoZW4ocmVzdWx0ID0+IHtcbiAgICAgIHJlc3RXaGVyZSA9IHJlc3VsdC5yZXN0V2hlcmUgfHwgcmVzdFdoZXJlO1xuICAgICAgcmVzdE9wdGlvbnMgPSByZXN1bHQucmVzdE9wdGlvbnMgfHwgcmVzdE9wdGlvbnM7XG4gICAgICBjb25zdCBxdWVyeSA9IG5ldyBSZXN0UXVlcnkoXG4gICAgICAgIGNvbmZpZyxcbiAgICAgICAgYXV0aCxcbiAgICAgICAgY2xhc3NOYW1lLFxuICAgICAgICByZXN0V2hlcmUsXG4gICAgICAgIHJlc3RPcHRpb25zLFxuICAgICAgICBjbGllbnRTREtcbiAgICAgICk7XG4gICAgICByZXR1cm4gcXVlcnkuZXhlY3V0ZSgpO1xuICAgIH0pO1xufTtcblxuLy8gUmV0dXJucyBhIHByb21pc2UgdGhhdCBkb2Vzbid0IHJlc29sdmUgdG8gYW55IHVzZWZ1bCB2YWx1ZS5cbmZ1bmN0aW9uIGRlbChjb25maWcsIGF1dGgsIGNsYXNzTmFtZSwgb2JqZWN0SWQsIGNvbnRleHQpIHtcbiAgaWYgKHR5cGVvZiBvYmplY3RJZCAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgUGFyc2UuRXJyb3IoUGFyc2UuRXJyb3IuSU5WQUxJRF9KU09OLCAnYmFkIG9iamVjdElkJyk7XG4gIH1cblxuICBpZiAoY2xhc3NOYW1lID09PSAnX1VzZXInICYmIGF1dGguaXNVbmF1dGhlbnRpY2F0ZWQoKSkge1xuICAgIHRocm93IG5ldyBQYXJzZS5FcnJvcihcbiAgICAgIFBhcnNlLkVycm9yLlNFU1NJT05fTUlTU0lORyxcbiAgICAgICdJbnN1ZmZpY2llbnQgYXV0aCB0byBkZWxldGUgdXNlcidcbiAgICApO1xuICB9XG5cbiAgZW5mb3JjZVJvbGVTZWN1cml0eSgnZGVsZXRlJywgY2xhc3NOYW1lLCBhdXRoKTtcblxuICBsZXQgaW5mbGF0ZWRPYmplY3Q7XG4gIGxldCBzY2hlbWFDb250cm9sbGVyO1xuXG4gIHJldHVybiBQcm9taXNlLnJlc29sdmUoKVxuICAgIC50aGVuKCgpID0+IHtcbiAgICAgIGNvbnN0IGhhc1RyaWdnZXJzID0gY2hlY2tUcmlnZ2VycyhjbGFzc05hbWUsIGNvbmZpZywgW1xuICAgICAgICAnYmVmb3JlRGVsZXRlJyxcbiAgICAgICAgJ2FmdGVyRGVsZXRlJyxcbiAgICAgIF0pO1xuICAgICAgY29uc3QgaGFzTGl2ZVF1ZXJ5ID0gY2hlY2tMaXZlUXVlcnkoY2xhc3NOYW1lLCBjb25maWcpO1xuICAgICAgaWYgKGhhc1RyaWdnZXJzIHx8IGhhc0xpdmVRdWVyeSB8fCBjbGFzc05hbWUgPT0gJ19TZXNzaW9uJykge1xuICAgICAgICByZXR1cm4gbmV3IFJlc3RRdWVyeShjb25maWcsIGF1dGgsIGNsYXNzTmFtZSwgeyBvYmplY3RJZCB9KVxuICAgICAgICAgIC5leGVjdXRlKHsgb3A6ICdkZWxldGUnIH0pXG4gICAgICAgICAgLnRoZW4ocmVzcG9uc2UgPT4ge1xuICAgICAgICAgICAgaWYgKHJlc3BvbnNlICYmIHJlc3BvbnNlLnJlc3VsdHMgJiYgcmVzcG9uc2UucmVzdWx0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgY29uc3QgZmlyc3RSZXN1bHQgPSByZXNwb25zZS5yZXN1bHRzWzBdO1xuICAgICAgICAgICAgICBmaXJzdFJlc3VsdC5jbGFzc05hbWUgPSBjbGFzc05hbWU7XG4gICAgICAgICAgICAgIGlmIChjbGFzc05hbWUgPT09ICdfU2Vzc2lvbicgJiYgIWF1dGguaXNNYXN0ZXIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWF1dGgudXNlciB8fCBmaXJzdFJlc3VsdC51c2VyLm9iamVjdElkICE9PSBhdXRoLnVzZXIuaWQpIHtcbiAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBQYXJzZS5FcnJvcihcbiAgICAgICAgICAgICAgICAgICAgUGFyc2UuRXJyb3IuSU5WQUxJRF9TRVNTSU9OX1RPS0VOLFxuICAgICAgICAgICAgICAgICAgICAnSW52YWxpZCBzZXNzaW9uIHRva2VuJ1xuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdmFyIGNhY2hlQWRhcHRlciA9IGNvbmZpZy5jYWNoZUNvbnRyb2xsZXI7XG4gICAgICAgICAgICAgIGNhY2hlQWRhcHRlci51c2VyLmRlbChmaXJzdFJlc3VsdC5zZXNzaW9uVG9rZW4pO1xuICAgICAgICAgICAgICBpbmZsYXRlZE9iamVjdCA9IFBhcnNlLk9iamVjdC5mcm9tSlNPTihmaXJzdFJlc3VsdCk7XG4gICAgICAgICAgICAgIHJldHVybiB0cmlnZ2Vycy5tYXliZVJ1blRyaWdnZXIoXG4gICAgICAgICAgICAgICAgdHJpZ2dlcnMuVHlwZXMuYmVmb3JlRGVsZXRlLFxuICAgICAgICAgICAgICAgIGF1dGgsXG4gICAgICAgICAgICAgICAgaW5mbGF0ZWRPYmplY3QsXG4gICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICBjb25maWcsXG4gICAgICAgICAgICAgICAgY29udGV4dFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IFBhcnNlLkVycm9yKFxuICAgICAgICAgICAgICBQYXJzZS5FcnJvci5PQkpFQ1RfTk9UX0ZPVU5ELFxuICAgICAgICAgICAgICAnT2JqZWN0IG5vdCBmb3VuZCBmb3IgZGVsZXRlLidcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHt9KTtcbiAgICB9KVxuICAgIC50aGVuKCgpID0+IHtcbiAgICAgIGlmICghYXV0aC5pc01hc3Rlcikge1xuICAgICAgICByZXR1cm4gYXV0aC5nZXRVc2VyUm9sZXMoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9KVxuICAgIC50aGVuKCgpID0+IGNvbmZpZy5kYXRhYmFzZS5sb2FkU2NoZW1hKCkpXG4gICAgLnRoZW4ocyA9PiB7XG4gICAgICBzY2hlbWFDb250cm9sbGVyID0gcztcbiAgICAgIGNvbnN0IG9wdGlvbnMgPSB7fTtcbiAgICAgIGlmICghYXV0aC5pc01hc3Rlcikge1xuICAgICAgICBvcHRpb25zLmFjbCA9IFsnKiddO1xuICAgICAgICBpZiAoYXV0aC51c2VyKSB7XG4gICAgICAgICAgb3B0aW9ucy5hY2wucHVzaChhdXRoLnVzZXIuaWQpO1xuICAgICAgICAgIG9wdGlvbnMuYWNsID0gb3B0aW9ucy5hY2wuY29uY2F0KGF1dGgudXNlclJvbGVzKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gY29uZmlnLmRhdGFiYXNlLmRlc3Ryb3koXG4gICAgICAgIGNsYXNzTmFtZSxcbiAgICAgICAge1xuICAgICAgICAgIG9iamVjdElkOiBvYmplY3RJZCxcbiAgICAgICAgfSxcbiAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgc2NoZW1hQ29udHJvbGxlclxuICAgICAgKTtcbiAgICB9KVxuICAgIC50aGVuKCgpID0+IHtcbiAgICAgIC8vIE5vdGlmeSBMaXZlUXVlcnkgc2VydmVyIGlmIHBvc3NpYmxlXG4gICAgICBjb25zdCBwZXJtcyA9IHNjaGVtYUNvbnRyb2xsZXIuZ2V0Q2xhc3NMZXZlbFBlcm1pc3Npb25zKGNsYXNzTmFtZSk7XG4gICAgICBjb25maWcubGl2ZVF1ZXJ5Q29udHJvbGxlci5vbkFmdGVyRGVsZXRlKFxuICAgICAgICBjbGFzc05hbWUsXG4gICAgICAgIGluZmxhdGVkT2JqZWN0LFxuICAgICAgICBudWxsLFxuICAgICAgICBwZXJtc1xuICAgICAgKTtcbiAgICAgIHJldHVybiB0cmlnZ2Vycy5tYXliZVJ1blRyaWdnZXIoXG4gICAgICAgIHRyaWdnZXJzLlR5cGVzLmFmdGVyRGVsZXRlLFxuICAgICAgICBhdXRoLFxuICAgICAgICBpbmZsYXRlZE9iamVjdCxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgY29uZmlnLFxuICAgICAgICBjb250ZXh0XG4gICAgICApO1xuICAgIH0pXG4gICAgLmNhdGNoKGVycm9yID0+IHtcbiAgICAgIGhhbmRsZVNlc3Npb25NaXNzaW5nRXJyb3IoZXJyb3IsIGNsYXNzTmFtZSwgYXV0aCk7XG4gICAgfSk7XG59XG5cbi8vIFJldHVybnMgYSBwcm9taXNlIGZvciBhIHtyZXNwb25zZSwgc3RhdHVzLCBsb2NhdGlvbn0gb2JqZWN0LlxuZnVuY3Rpb24gY3JlYXRlKGNvbmZpZywgYXV0aCwgY2xhc3NOYW1lLCByZXN0T2JqZWN0LCBjbGllbnRTREssIGNvbnRleHQpIHtcbiAgZW5mb3JjZVJvbGVTZWN1cml0eSgnY3JlYXRlJywgY2xhc3NOYW1lLCBhdXRoKTtcbiAgdmFyIHdyaXRlID0gbmV3IFJlc3RXcml0ZShcbiAgICBjb25maWcsXG4gICAgYXV0aCxcbiAgICBjbGFzc05hbWUsXG4gICAgbnVsbCxcbiAgICByZXN0T2JqZWN0LFxuICAgIG51bGwsXG4gICAgY2xpZW50U0RLLFxuICAgIGNvbnRleHRcbiAgKTtcbiAgcmV0dXJuIHdyaXRlLmV4ZWN1dGUoKTtcbn1cblxuLy8gUmV0dXJucyBhIHByb21pc2UgdGhhdCBjb250YWlucyB0aGUgZmllbGRzIG9mIHRoZSB1cGRhdGUgdGhhdCB0aGVcbi8vIFJFU1QgQVBJIGlzIHN1cHBvc2VkIHRvIHJldHVybi5cbi8vIFVzdWFsbHksIHRoaXMgaXMganVzdCB1cGRhdGVkQXQuXG5mdW5jdGlvbiB1cGRhdGUoXG4gIGNvbmZpZyxcbiAgYXV0aCxcbiAgY2xhc3NOYW1lLFxuICByZXN0V2hlcmUsXG4gIHJlc3RPYmplY3QsXG4gIGNsaWVudFNESyxcbiAgY29udGV4dFxuKSB7XG4gIGVuZm9yY2VSb2xlU2VjdXJpdHkoJ3VwZGF0ZScsIGNsYXNzTmFtZSwgYXV0aCk7XG5cbiAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG4gICAgLnRoZW4oKCkgPT4ge1xuICAgICAgY29uc3QgaGFzVHJpZ2dlcnMgPSBjaGVja1RyaWdnZXJzKGNsYXNzTmFtZSwgY29uZmlnLCBbXG4gICAgICAgICdiZWZvcmVTYXZlJyxcbiAgICAgICAgJ2FmdGVyU2F2ZScsXG4gICAgICBdKTtcbiAgICAgIGNvbnN0IGhhc0xpdmVRdWVyeSA9IGNoZWNrTGl2ZVF1ZXJ5KGNsYXNzTmFtZSwgY29uZmlnKTtcbiAgICAgIGlmIChoYXNUcmlnZ2VycyB8fCBoYXNMaXZlUXVlcnkpIHtcbiAgICAgICAgLy8gRG8gbm90IHVzZSBmaW5kLCBhcyBpdCBydW5zIHRoZSBiZWZvcmUgZmluZHNcbiAgICAgICAgcmV0dXJuIG5ldyBSZXN0UXVlcnkoXG4gICAgICAgICAgY29uZmlnLFxuICAgICAgICAgIGF1dGgsXG4gICAgICAgICAgY2xhc3NOYW1lLFxuICAgICAgICAgIHJlc3RXaGVyZSxcbiAgICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgICAgdW5kZWZpbmVkLFxuICAgICAgICAgIGZhbHNlXG4gICAgICAgICkuZXhlY3V0ZSh7XG4gICAgICAgICAgb3A6ICd1cGRhdGUnLFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe30pO1xuICAgIH0pXG4gICAgLnRoZW4oKHsgcmVzdWx0cyB9KSA9PiB7XG4gICAgICB2YXIgb3JpZ2luYWxSZXN0T2JqZWN0O1xuICAgICAgaWYgKHJlc3VsdHMgJiYgcmVzdWx0cy5sZW5ndGgpIHtcbiAgICAgICAgb3JpZ2luYWxSZXN0T2JqZWN0ID0gcmVzdWx0c1swXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgUmVzdFdyaXRlKFxuICAgICAgICBjb25maWcsXG4gICAgICAgIGF1dGgsXG4gICAgICAgIGNsYXNzTmFtZSxcbiAgICAgICAgcmVzdFdoZXJlLFxuICAgICAgICByZXN0T2JqZWN0LFxuICAgICAgICBvcmlnaW5hbFJlc3RPYmplY3QsXG4gICAgICAgIGNsaWVudFNESyxcbiAgICAgICAgY29udGV4dCxcbiAgICAgICAgJ3VwZGF0ZSdcbiAgICAgICkuZXhlY3V0ZSgpO1xuICAgIH0pXG4gICAgLmNhdGNoKGVycm9yID0+IHtcbiAgICAgIGhhbmRsZVNlc3Npb25NaXNzaW5nRXJyb3IoZXJyb3IsIGNsYXNzTmFtZSwgYXV0aCk7XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIGhhbmRsZVNlc3Npb25NaXNzaW5nRXJyb3IoZXJyb3IsIGNsYXNzTmFtZSwgYXV0aCkge1xuICAvLyBJZiB3ZSdyZSB0cnlpbmcgdG8gdXBkYXRlIGEgdXNlciB3aXRob3V0IC8gd2l0aCBiYWQgc2Vzc2lvbiB0b2tlblxuICBpZiAoXG4gICAgY2xhc3NOYW1lID09PSAnX1VzZXInICYmXG4gICAgZXJyb3IuY29kZSA9PT0gUGFyc2UuRXJyb3IuT0JKRUNUX05PVF9GT1VORCAmJlxuICAgICFhdXRoLmlzTWFzdGVyXG4gICkge1xuICAgIHRocm93IG5ldyBQYXJzZS5FcnJvcihQYXJzZS5FcnJvci5TRVNTSU9OX01JU1NJTkcsICdJbnN1ZmZpY2llbnQgYXV0aC4nKTtcbiAgfVxuICB0aHJvdyBlcnJvcjtcbn1cblxuY29uc3QgY2xhc3Nlc1dpdGhNYXN0ZXJPbmx5QWNjZXNzID0gW1xuICAnX0pvYlN0YXR1cycsXG4gICdfUHVzaFN0YXR1cycsXG4gICdfSG9va3MnLFxuICAnX0dsb2JhbENvbmZpZycsXG4gICdfSm9iU2NoZWR1bGUnLFxuICAnX0lkZW1wb3RlbmN5Jyxcbl07XG4vLyBEaXNhbGxvd2luZyBhY2Nlc3MgdG8gdGhlIF9Sb2xlIGNvbGxlY3Rpb24gZXhjZXB0IGJ5IG1hc3RlciBrZXlcbmZ1bmN0aW9uIGVuZm9yY2VSb2xlU2VjdXJpdHkobWV0aG9kLCBjbGFzc05hbWUsIGF1dGgpIHtcbiAgaWYgKGNsYXNzTmFtZSA9PT0gJ19JbnN0YWxsYXRpb24nICYmICFhdXRoLmlzTWFzdGVyKSB7XG4gICAgaWYgKG1ldGhvZCA9PT0gJ2RlbGV0ZScgfHwgbWV0aG9kID09PSAnZmluZCcpIHtcbiAgICAgIGNvbnN0IGVycm9yID0gYENsaWVudHMgYXJlbid0IGFsbG93ZWQgdG8gcGVyZm9ybSB0aGUgJHttZXRob2R9IG9wZXJhdGlvbiBvbiB0aGUgaW5zdGFsbGF0aW9uIGNvbGxlY3Rpb24uYDtcbiAgICAgIHRocm93IG5ldyBQYXJzZS5FcnJvcihQYXJzZS5FcnJvci5PUEVSQVRJT05fRk9SQklEREVOLCBlcnJvcik7XG4gICAgfVxuICB9XG5cbiAgLy9hbGwgdm9sYXRpbGVDbGFzc2VzIGFyZSBtYXN0ZXJLZXkgb25seVxuICBpZiAoY2xhc3Nlc1dpdGhNYXN0ZXJPbmx5QWNjZXNzLmluZGV4T2YoY2xhc3NOYW1lKSA+PSAwICYmICFhdXRoLmlzTWFzdGVyKSB7XG4gICAgY29uc3QgZXJyb3IgPSBgQ2xpZW50cyBhcmVuJ3QgYWxsb3dlZCB0byBwZXJmb3JtIHRoZSAke21ldGhvZH0gb3BlcmF0aW9uIG9uIHRoZSAke2NsYXNzTmFtZX0gY29sbGVjdGlvbi5gO1xuICAgIHRocm93IG5ldyBQYXJzZS5FcnJvcihQYXJzZS5FcnJvci5PUEVSQVRJT05fRk9SQklEREVOLCBlcnJvcik7XG4gIH1cblxuICAvLyByZWFkT25seSBtYXN0ZXJLZXkgaXMgbm90IGFsbG93ZWRcbiAgaWYgKFxuICAgIGF1dGguaXNSZWFkT25seSAmJlxuICAgIChtZXRob2QgPT09ICdkZWxldGUnIHx8IG1ldGhvZCA9PT0gJ2NyZWF0ZScgfHwgbWV0aG9kID09PSAndXBkYXRlJylcbiAgKSB7XG4gICAgY29uc3QgZXJyb3IgPSBgcmVhZC1vbmx5IG1hc3RlcktleSBpc24ndCBhbGxvd2VkIHRvIHBlcmZvcm0gdGhlICR7bWV0aG9kfSBvcGVyYXRpb24uYDtcbiAgICB0aHJvdyBuZXcgUGFyc2UuRXJyb3IoUGFyc2UuRXJyb3IuT1BFUkFUSU9OX0ZPUkJJRERFTiwgZXJyb3IpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBjcmVhdGUsXG4gIGRlbCxcbiAgZmluZCxcbiAgZ2V0LFxuICB1cGRhdGUsXG59O1xuIl19